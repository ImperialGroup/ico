
    # This is the chain name in populus.json
    # In the default configuration this Ethereum JSON-RPC in port 8547.
    # Edit populus.json to change the port.
    # You can run Parity as:
    # parity \
    #   --chain=kovan \
    #   --unlock [My deploy account on Parity] \
    #   --jsonrpc-port 8547 \
    #   --password=password.txt
    #
    # password.txt must contain your Parity Kovan account unlock password
chain: local

    # Use automated Chrome to verify all contracts on etherscan.io
verify_on_etherscan: no
browser_driver: chrome

solc:

        # This is the Solidity version tag we verify on EtherScan.
        # For available versions see
        # https://kovan.etherscan.io/verifyContract2
        #
        # See values in Compiler drop down.
        # You can also get the local compiler version with:
        #
        #     solc --version
        #
        # Note that for EtherScan you need to add letter "v" at the front of the version
        #
        # Note: You need to have correct optmization settings for the compiler
        # in populus.json that matches what EtherScan is expecting.
        #
  version: v0.4.14+commit.c2215d46

        #
        # We supply these to EtherScan as the solc settings we used to compile the contract.
        # They must match values in populus.json compilication / backends section.
        #
  optimizations:
    optimizer: true
    runs: 500     

contracts:
        # This is the address of the multisig wallet where the paymnts eventually land
  team_multisig:
    contract_name: MultiSigWallet
    contract_file: GnosisWallet.sol
    address: '0x3f8b316bdb8aae177f3ed6739a5a4ef5e942b9d5'
        #
        # Token contract
        #
        # This contract represents ERC-20 token.
        # It has transfer lock up functionality to prevent the token to be transferable
        # until the ICO is over.
        #
        # We create the whole token supply upfront and no more token minting
        # happens ever.
        #
        # Token has 18 decimals and supply of 1B tokens.
        #
        # Token supply is one billion tokens.
        #
        # Name and symbol are not set yet. They are set later. In
        # the case of the deployment fails and we need redeploy
        # we do not create unnecessary entries in token explorers.
        #
  token: !!omap
  - contract_name: BurnableCrowdsaleToken
  - contract_file: BurnableCrowdsaleToken.sol
  - arguments: !!omap
    - _name: WhiteListToken3
    - _symbol: WLT3
    - _initialSupply: 100000000000000000000000000000
    - _decimals: 18
    - _mintable: false
  - address: '0xe10e756b78dd125d4c62fdb831d2c7b5661908a1'
  - constructor_args: '0x00000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000001431e0fae6d7217caa000000000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f57686974654c697374546f6b656e3300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004574c543300000000000000000000000000000000000000000000000000000000'
  - libraries:
      SafeMathLib: '0xc47a381f589d7755e92ac276c69ea928556d4349'
        #
        # Pricing strategy.
        #
        # We use ETH tranches. People who buy in in the first
        # tranches get 20% and 10% bonus tokens.
        #
  pricing_strategy: !!omap
  - contract_name: EthTranchePricing
  - contract_file: EthTranchePricing.sol
  - arguments: !!omap
    - _tranches:
      - 0
      - 1000000000000000
      - 100000000000000000000
      - 2000000000000000
      - 200000000000000000000
      - 5000000000000000
      - 999999999999999000000000000000000
      - 0
  - address: '0x85aa5715db68f10d9821fb47efd69c28b60f8032'
  - constructor_args: '0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000038d7ea4c680000000000000000000000000000000000000000000000000056bc75e2d6310000000000000000000000000000000000000000000000000000000071afd498d000000000000000000000000000000000000000000000000000ad78ebc5ac62000000000000000000000000000000000000000000000000000000011c37937e08000000000000000000000000000000000000000314dc6448d932ae0a456589c00000000000000000000000000000000000000000000000000000000000000000000'
  - libraries:
      SafeMathLib: '0x024b851dc45da14c2a07d8a7fe5141f214990691'
  crowdsale: !!omap
  - contract_name: AllocatedCrowdsale
  - contract_file: AllocatedCrowdsale.sol
  - arguments: !!omap
    - _token: '0xe10e756b78dd125d4c62fdb831d2c7b5661908a1'
    - _pricingStrategy: '0x85aa5715db68f10d9821fb47efd69c28b60f8032'
    - _multisigWallet: '0x3f8b316bdb8aae177f3ed6739a5a4ef5e942b9d5'
    - _start: 1524488400
    - _end: 1527080400
    - _minimumFundingGoal: 1000000000000000000000
    - _beneficiary: '0x727efeddfaae32231415a0ab457785dbf6aff9b2'
  - address: '0x8238a94f9856571662e9a517481e06b52c7c5d66'
  - constructor_args: '0x000000000000000000000000e10e756b78dd125d4c62fdb831d2c7b5661908a100000000000000000000000085aa5715db68f10d9821fb47efd69c28b60f80320000000000000000000000003f8b316bdb8aae177f3ed6739a5a4ef5e942b9d5000000000000000000000000000000000000000000000000000000005addd8d0000000000000000000000000000000000000000000000000000000005b0565d000000000000000000000000000000000000000000000003635c9adc5dea00000000000000000000000000000727efeddfaae32231415a0ab457785dbf6aff9b2'
  - libraries:
      SafeMathLib: '0x49818f6964ef16a8bcdf75b4fd012abc33b5b46f'

        # Because deploy_address controls whole supply,
        # we do not create any supply dynamically,
        # we do not need a finalizer.
        #
  finalize_agent: !!omap
  - contract_name: NullFinalizeAgent
  - contract_file: NullFinalizeAgent.sol
  - arguments: !!omap
    - _crowdsale: '0x8238a94f9856571662e9a517481e06b52c7c5d66'
  - address: '0x10df42006d0562201073afa8530cf3de27aab6a1'
  - constructor_args: '0x0000000000000000000000008238a94f9856571662e9a517481e06b52c7c5d66'
  - libraries: {}

    # Post-deployment actions connect contracts together.
post_actions: |2

  # Allow crowdsale contract to sell its token
  token.transact({"from": deploy_address}).approve(crowdsale.address, 70000000000*10**18)

  # Make sure crowdsale contract and these accounts
  # can transfer tokens despite transfer lock up
  token.transact({"from": deploy_address}).setTransferAgent(team_multisig.address, True)
  token.transact({"from": deploy_address}).setTransferAgent(crowdsale.address, True)
  token.transact({"from": deploy_address}).setTransferAgent(finalize_agent.address, True)
  token.transact({"from": deploy_address}).setTransferAgent(deploy_address, True)

  # Do not do nothing at the end of the crowdsale
  confirm_tx(crowdsale.transact({"from": deploy_address}).setFinalizeAgent(finalize_agent.address))

  # Owner can release the token transfer when they fel its the time
  confirm_tx(token.transact({"from": deploy_address}).setReleaseAgent(deploy_address))

  # Set token upgrade master to team multisig to give the new token path
  confirm_tx(token.transact({"from": deploy_address}).setUpgradeMaster(team_multisig.address))

  # Allow test buys from these accounts before token sale begins.
  # The latter one is a presale contract address.
  # Presale contract (PreICOProxyBuyer) can move in funds
  # and get tokens before the actual start time.
  #confirm_multiple_txs( \
  #  crowdsale.transact({"from": deploy_address}).setEarlyParicipantWhitelist(deploy_address, True), \
  #  crowdsale.transact({"from": deploy_address}).setEarlyParicipantWhitelist("0x77cA2e7E9AA9f0494560Ed0EAcBE1B1B90F9fcb6", True) \
  #)

  # Add Deployer Address to Whitelist
     crowdsale.transact({"from": deploy_address}).addAddressToWhitelist(deploy_address)

  # We set a special price, outside ETH tranches, for a presale contract
  # confirm_tx(pricing_strategy.transact({"from": deploy_address}).setPreicoAddress("0x6d997eDcA04282950416FA380d834f360fC36eBb", 2083333333333))

# Sanity check
verify_actions: |
  assert token.call().owner().lower() == deploy_address.lower()
  assert token.call().released() == False
  assert crowdsale.call().owner().lower() == deploy_address.lower()
  assert crowdsale.call().multisigWallet().lower() == team_multisig.address.lower()
  assert finalize_agent.call().isSane()
  # assert crowdsale.call().getState() == CrowdsaleState.PreFunding   # PreFunding for the final, as it is deployed pre-opening

  # Do a test buy using a test address.
  # This ensures are variables are set and the
  # funds flow in the multisig wallet.
  confirm_tx(crowdsale.transact({"from": deploy_address, "value": to_wei("0.01", "ether")}).buy())

  # As the last action, after successful deployment, set the right token symbol and name so that it shows in a blockchain explorer
  # confirm_tx(token.transact({"from": deploy_address}).setTokenInformation("MooToken", "MOO"))

deploy_address: '0x727efeddfaae32231415a0ab457785dbf6aff9b2'
